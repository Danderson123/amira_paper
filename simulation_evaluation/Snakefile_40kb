
import os
import random
from Bio import SeqIO
from tqdm import tqdm
import numpy as np
import json
import pyfastaq
import pandas as pd
import json
import glob
import statistics
import matplotlib.pyplot as plt

# Define the parameters
AMR_allele_file = "AMR_alleles_unified.fa"
output_dir = 'simulations_40kb_r10'
badread_length = "40000,36015.5"
seed = 42  # Seed for reproducibility
random.seed(seed)
np.random.seed(seed)

SAMPLES = [os.path.basename(f).replace(".fasta", "").replace(".fa", "") for f in glob.glob("AMR_contexts/*")]
DEPTHS = [5, 10, 20, 40, 80]

def aggregate_outputs(wildcards):
    return expand(os.path.join(output_dir, "amira" + "_{depth}", "{sample}"), depth=DEPTHS, sample=SAMPLES)

def aggregate_stats(wildcards):
    return expand(os.path.join(output_dir, "summary_stats", "{sample}"), sample=SAMPLES)

def aggregate_assems(wildcards):
    return expand(os.path.join("simulated_assemblies", "{sample}.fasta"), sample=SAMPLES)

def aggregate_flye(wildcards):
    return expand(os.path.join(output_dir, "AMRFP_flye" + "_{depth}", "{sample}", "AMR_finder_plus_results.tsv"), depth=DEPTHS, sample=SAMPLES)

def aggregate_amira(wildcards):
    return expand(os.path.join(output_dir, "amira" + "_{depth}", "{sample}"), depth=DEPTHS, sample=SAMPLES)

# Define the workflow
rule all:
    input:
        aggregate_outputs,
        aggregate_stats,
        aggregate_flye,
        aggregate_amira

# Snakemake rule for simulating assemblies
rule simulate_assembly:
    input:
        reference_genome="reference_genome.fasta",
        reference_plasmid="reference_plasmid.fasta",
        context_fasta= lambda wildcards: os.path.join("AMR_contexts", wildcards.sample + ".fasta")
    output:
        os.path.join('simulated_assemblies', "{sample}.fasta")
    params:
        allele_file=AMR_allele_file
    run:
        # Load the reference assembly
        genome = pyfastaq.sequences.file_reader(input.reference_genome)
        # Get the genome length and sequence
        genome_length, genome_seq = 0, ""
        for sequence in genome:
            genome_length = len(sequence.seq)
            genome_seq = str(sequence.seq)

        # Load the reference plasmid
        plasmid = pyfastaq.sequences.file_reader(input.reference_plasmid)
        # Get the plasmid length and sequence
        plasmid_length, plasmid_seq = 0, ""
        for sequence in plasmid:
            plasmid_length = len(sequence.seq)
            plasmid_seq = str(sequence.seq)

        # get the true amr gene content of the block
        try:
            out_gff = output[0].replace('.fasta', '.AMR_content.gff')
            shell("python3 scripts/make_truth_with_minimap.py {input.context_fasta} {params.allele_file} {out_gff}")
            # process the gff file
            gff_content = {}
            with open(out_gff) as i:
                annotations, sequence = i.read().split("##FASTA")
            for line in annotations.split("\n"):
                if not line.startswith("#"):
                    if line == "":
                        continue
                    region, source, a_type, start, end, _, strand, dot, feature = line.split("\t")
                    if region not in gff_content:
                        gff_content[region] = []
                    gff_content[region].append((int(start) - 1, int(end) - int(start), feature.replace("Name=", ""), strand))
            for r in gff_content:
                gff_content[r] = sorted(gff_content[r], key=lambda x: x[0])
        except:
            pass
        # Load the context file
        context = pyfastaq.sequences.file_reader(input.context_fasta)
        # Decide where we are putting the AMR blocks
        block_insertions = [[], []]
        for sequence in context:
            if "_chromosome" in sequence.id:
                block_insertions[0].append((sequence.id, str(sequence.seq)))
            elif "_plasmid" in sequence.id:
                block_insertions[1].append((sequence.id, str(sequence.seq)))
        # decide where the blocks will be inserted in the chromosome
        chromosome_insertions = sorted(random.sample(range(len(genome_seq)), len(block_insertions[0])))
        # decide where the blocks will be inserted in the plasmid
        plasmid_insertions = sorted(random.sample(range(len(plasmid_seq)), len(block_insertions[1])))
        # decide the plasmid copy number
        plasmid_copy_number = random.randint(1, 10)
        # split the chromosome into blocks at the insertion points
        chromosome_fragments = []
        next_start = 0
        for position in chromosome_insertions:
            chromosome_fragments.append(genome_seq[next_start:position])
            next_start = position
        chromosome_fragments.append(genome_seq[next_start:])
        # split the plasmid into blocks at the insertion points
        plasmid_fragments = []
        next_start = 0
        for position in plasmid_insertions:
            plasmid_fragments.append(plasmid_seq[next_start:position])
            next_start = position
        plasmid_fragments.append(plasmid_seq[next_start:])
        # collect amr gene positions
        context_tsv = ["Allele name\tContig\tStart\tEnd\tLength\tStrand\tCopy number"]
        # get the chromsome assembly
        simulated_chromosome = []
        offset = 0
        for i in range(len(chromosome_insertions)):
            simulated_chromosome.append(chromosome_fragments[i])
            simulated_chromosome.append(block_insertions[0][i][1])
            adjusted_start = offset + chromosome_insertions[i] + 1
            if block_insertions[0][i][0] in gff_content:
                for amr_start, amr_length, amr_allele, amr_strand in gff_content[block_insertions[0][i][0]]:
                    context_tsv.append(f"{amr_allele}\tchromosome\t{adjusted_start + amr_start}\t{adjusted_start + amr_start + amr_length}\t{amr_length}\t{amr_strand}\t1")
            offset += len(block_insertions[0][i][1])
        simulated_chromosome.append(chromosome_fragments[-1])
        # get the plasmid assembly
        simulated_plasmid = []
        offset = 0
        for i in range(len(plasmid_insertions)):
            simulated_plasmid.append(plasmid_fragments[i])
            simulated_plasmid.append(block_insertions[1][i][1])
            adjusted_start = offset + plasmid_insertions[i] + 1
            if block_insertions[1][i][0] in gff_content:
                for amr_start, amr_length, amr_allele, amr_strand in gff_content[block_insertions[1][i][0]]:
                    context_tsv.append(f"{amr_allele}\tplasmid\t{adjusted_start + amr_start}\t{adjusted_start + amr_start + amr_length}\t{amr_length}\t{amr_strand}\t{plasmid_copy_number}")
            offset += len(block_insertions[1][i][1])
        simulated_plasmid.append(plasmid_fragments[-1])
        # make the simulated assembly
        simulated_assembly = []
        simulated_chromosome_header = ">contig_1,circular=true"
        simulated_assembly.append(simulated_chromosome_header)
        simulated_assembly.append("".join(simulated_chromosome))
        for i in range(plasmid_copy_number):
            plasmid_header = f">plasmid_{i + 1},circular=true"
            simulated_assembly.append(plasmid_header)
            simulated_assembly.append("".join(simulated_plasmid))
        # Join the simulated assembly into a single string
        simulated_assembly_str = "\n".join(simulated_assembly)
        # write the outputs
        if not os.path.exists(os.path.dirname(output[0])):
            os.mkdir(os.path.dirname(output[0]))
        with open(output[0], "w") as o:
            o.write(simulated_assembly_str)
        with open(output[0].replace(".fasta", ".AMR_genes.tsv"), "w") as o:
            o.write("\n".join(context_tsv))

rule simulate_r_10_reads:
    input:
        assembly=os.path.join("simulated_assemblies", "{sample}.fasta")
    output:
        os.path.join(output_dir, "reads" + "_{depth}", "{sample}_1.fastq")
    resources:
        mem_mb=30000, threads=1
    threads: 1
    params:
        sim_depth="{depth}",
        mean_length=badread_length
    shell:
        "badread simulate --seed 2024 --length {params.mean_length} --error_model nanopore2023 --qscore_model nanopore2023 --reference {input.assembly} --quantity {params.sim_depth}x > {output}"

rule run_amira:
    input:
        readfile=os.path.join(output_dir, "reads" + "_{depth}", "{sample}_1.fastq")
    output:
        directory(os.path.join(output_dir, "amira" + "_{depth}", "{sample}"))
    threads: 5
    resources:
        mem_mb=lambda wildcards, attempt: 50000 * attempt, threads=5, runtime=7200
    params:
        panRG="AMR_supplemented_panRG.k15.w5.panidx.zip",
        species="Escherichia_coli"
    shell:
        "singularity run amira.img amira --pandora-path /hps/nobackup/iqbal/dander/Amira_truth_evaluation/software/pandora-linux-precompiled-v0.12.0-alpha.0 --reads {input.readfile} --output {output} --species {params.species} --cores {threads} --panRG-path {params.panRG}"


rule unicycler_assemble:
    input:
        readfile=os.path.join(output_dir, "reads" + "_{depth}", "{sample}_1.fastq")
    output:
        directory(os.path.join(output_dir, "unicycler" + "_{depth}", "{sample}"))
    threads: 4
    resources:
        mem_mb=100000
    conda: "envs/unicycler.yaml"
    shell:
        """
        {{
            unicycler -l {input.readfile} -o {output} -t {threads} --keep 3
        }} || {{
            mkdir -p {output} && touch {output}/assembly.fasta
        }}
        """

rule flye_assemble:
    input:
        readfile=os.path.join(output_dir, "reads" + "_{depth}", "{sample}_1.fastq")
    output:
        directory(os.path.join(output_dir, "flye" + "_{depth}", "{sample}"))
    threads: 4
    resources:
        mem_mb=100000
    conda: "envs/flye.yaml"
    shell:
        "flye -g 5M -o {output} -t {threads} -i 2 --nano-raw {input.readfile}"

rule run_amrfp_on_unicycler:
    input:
        os.path.join(output_dir, "unicycler" + "_{depth}", "{sample}")
    output:
        outdir=directory(os.path.join(output_dir, "AMRFP_unicycler" + "_{depth}", "{sample}")),
        outfile=os.path.join(output_dir, "AMRFP_unicycler" + "_{depth}", "{sample}", "AMR_finder_plus_results.tsv")
    threads: 4
    resources:
        mem_mb=15000
    shell:
        "mkdir -p {output.outdir} && amrfinder -n {input}/assembly.fasta -o {output.outfile} -t {threads} --plus --organism Escherichia"

rule run_amrfp_on_flye:
    input:
        os.path.join(output_dir, "flye" + "_{depth}", "{sample}")
    output:
        outdir=directory(os.path.join(output_dir, "AMRFP_flye" + "_{depth}", "{sample}")),
        outfile=os.path.join(output_dir, "AMRFP_flye" + "_{depth}", "{sample}", "AMR_finder_plus_results.tsv")
    threads: 4
    resources:
        mem_mb=15000
    shell:
        "mkdir -p {output.outdir} && amrfinder -n {input}/assembly.fasta -o {output.outfile} -t {threads} --plus --organism Escherichia"
